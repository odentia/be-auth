name: Deploy to VPS

on:
  workflow_dispatch:
  workflow_run:
    workflows: ["Build and Push Docker images to GHCR"]
    types:
      - completed

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: read
      packages: read

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          script: |
            mkdir -p ~/be-auth
            cd ~/be-auth
            
            POSTGRES_PORT="${{ secrets.POSTGRES_PORT || '5435' }}"
            HTTP_PORT="${{ secrets.HTTP_PORT || '8011' }}"
            REDIS_PORT="${{ secrets.REDIS_PORT || '6379' }}"
            RABBITMQ_CONTAINER_NAME="${{ secrets.RABBITMQ_CONTAINER_NAME || 'rabbitmq' }}"
            RABBITMQ_NETWORK="${{ secrets.RABBITMQ_NETWORK }}"
            
            # Формируем DATABASE_URL из компонентов, если не задан в секретах
            POSTGRES_DB="${{ secrets.POSTGRES_DB || 'auth' }}"
            POSTGRES_USER="${{ secrets.POSTGRES_USER || 'auth_user' }}"
            POSTGRES_PASSWORD="${{ secrets.POSTGRES_PASSWORD }}"
            
            # Проверяем и формируем DATABASE_URL
            SECRET_DATABASE_URL="${{ secrets.DATABASE_URL }}"
            if [ -z "$SECRET_DATABASE_URL" ]; then
              DATABASE_URL="postgresql+asyncpg://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}"
            else
              DATABASE_URL="$SECRET_DATABASE_URL"
            fi
            
            # Проверяем и формируем ALEMBIC_DATABASE_URL
            SECRET_ALEMBIC_DATABASE_URL="${{ secrets.ALEMBIC_DATABASE_URL }}"
            if [ -z "$SECRET_ALEMBIC_DATABASE_URL" ]; then
              ALEMBIC_DATABASE_URL="postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}"
            else
              ALEMBIC_DATABASE_URL="$SECRET_ALEMBIC_DATABASE_URL"
            fi
            
            echo "Используемые порты:"
            echo "  PostgreSQL: $POSTGRES_PORT"
            echo "  HTTP: $HTTP_PORT"
            echo "  Redis: $REDIS_PORT"
            echo "База данных: $POSTGRES_DB"
            echo "Пользователь: $POSTGRES_USER"
            
            # Определяем сеть существующего контейнера, если не указана
            if [ -z "$RABBITMQ_NETWORK" ]; then
              FORMAT='{{range $key, $value := .NetworkSettings.Networks}}{{$key}}{{end}}'
              RABBITMQ_NETWORK=$(docker inspect "$RABBITMQ_CONTAINER_NAME" --format="$FORMAT" 2>/dev/null | head -n1 || echo "bridge")
            fi
            
            # Используем имя существующего контейнера в RABBITMQ_URL
            RABBITMQ_HOST="$RABBITMQ_CONTAINER_NAME"
            
            # Если сеть существует, подключаем be-auth к ней
            if docker network inspect "$RABBITMQ_NETWORK" >/dev/null 2>&1; then
              USE_EXTERNAL_RABBITMQ_NETWORK=1
            else
              USE_EXTERNAL_RABBITMQ_NETWORK=0
            fi
            
            cat > docker-compose.yml << EOF
            services:
              postgres:
                image: postgres:16-alpine
                container_name: be-auth-postgres
                restart: unless-stopped
                environment:
                  POSTGRES_DB: ${POSTGRES_DB}
                  POSTGRES_USER: ${POSTGRES_USER}
                  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                ports:
                  - "${POSTGRES_PORT}:5432"
                networks:
                  - be-auth-network
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
              redis:
                image: redis:7-alpine
                container_name: be-auth-redis
                restart: unless-stopped
                ports:
                  - "${REDIS_PORT}:6379"
                networks:
                  - be-auth-network
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
              be-auth:
                image: ghcr.io/${{ github.repository_owner }}/be-auth:latest
                container_name: be-auth
                restart: unless-stopped
                depends_on:
                  postgres:
                    condition: service_healthy
                  redis:
                    condition: service_healthy
                ports:
                  - "${HTTP_PORT}:8000"
                environment:
                  - DATABASE_URL=${DATABASE_URL}
                  - ALEMBIC_DATABASE_URL=${ALEMBIC_DATABASE_URL}
                  - REDIS_URL=${{ secrets.REDIS_URL || 'redis://redis:6379/0' }}
                  - RABBITMQ_USER=${{ secrets.RABBITMQ_USER || 'guest' }}
                  - RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD || 'guest' }}
                  - RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER || 'guest' }}:${{ secrets.RABBITMQ_PASSWORD || 'guest' }}@${RABBITMQ_HOST}:5672/
                  - HTTP_PORT=8000
                  - ENV=prod
                  - LOG_LEVEL=${{ secrets.LOG_LEVEL || 'INFO' }}
                  - CORS_ALLOW_ORIGINS=${{ secrets.CORS_ALLOW_ORIGINS || '*' }}
                networks:
                  - be-auth-network
            networks:
              be-auth-network:
                driver: bridge
            volumes:
              postgres_data:
            EOF
            
            cat > .env << EOF
            POSTGRES_DB=${POSTGRES_DB}
            POSTGRES_USER=${POSTGRES_USER}
            POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
            DATABASE_URL=${DATABASE_URL}
            ALEMBIC_DATABASE_URL=${ALEMBIC_DATABASE_URL}
            REDIS_URL=${{ secrets.REDIS_URL || 'redis://redis:6379/0' }}
            RABBITMQ_USER=${{ secrets.RABBITMQ_USER || 'guest' }}
            RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD || 'guest' }}
            RABBITMQ_URL=amqp://${{ secrets.RABBITMQ_USER || 'guest' }}:${{ secrets.RABBITMQ_PASSWORD || 'guest' }}@${RABBITMQ_HOST}:5672/
            HTTP_PORT=8000
            ENV=prod
            LOG_LEVEL=${{ secrets.LOG_LEVEL || 'INFO' }}
            CORS_ALLOW_ORIGINS=${{ secrets.CORS_ALLOW_ORIGINS || '*' }}
            EOF
            
            # Логинимся в GHCR для доступа к образам
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin || {
              echo "Failed to login to GHCR, trying with GHCR_TOKEN if available"
              if [ -n "${{ secrets.GHCR_TOKEN }}" ]; then
                echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
              fi
            }
            # Подключаем be-auth к сети существующего RabbitMQ
            echo "Используется существующий RabbitMQ контейнер: $RABBITMQ_CONTAINER_NAME"
            echo "Сеть: $RABBITMQ_NETWORK"
            
            # Останавливаем и удаляем старые контейнеры по именам
            docker stop be-auth be-auth-postgres be-auth-redis be-auth-rabbitmq 2>/dev/null || true
            docker rm be-auth be-auth-postgres be-auth-redis be-auth-rabbitmq 2>/dev/null || true
            
            # Останавливаем compose если он был запущен
            docker compose down --remove-orphans 2>/dev/null || true
            
            docker compose pull
            docker compose run --rm be-auth uv run alembic upgrade head || echo "Migration failed or not needed"
            docker compose up -d --remove-orphans
            
            # Подключаем be-auth к сети существующего RabbitMQ после запуска
            if [ "$USE_EXTERNAL_RABBITMQ_NETWORK" = "1" ]; then
              docker network connect "$RABBITMQ_NETWORK" be-auth 2>/dev/null || echo "Контейнер be-auth уже подключен к сети $RABBITMQ_NETWORK"
            fi
            
            docker image prune -f
